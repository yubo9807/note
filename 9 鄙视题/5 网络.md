# 网络

## 浏览器中输入 url 回车，会发生什么？

- DNS 解析：
  1. 首先在本机的 host 文件中寻找，如果没有看路由器的缓存中有无记录，没有接着向 DNS 服务器发出请求；
  2. host 文件或 DNS 服务器返回对应的 IP 地址；
  3. 浏览器请求该 IP 地址；
  4. IP 服务器返回相应的页面。

- 页面解析：
    1. HTML 词法分析和语法解析；
    2. CSS 解析；
    3. 合成图层、合成线程调用光栅化线程池；
    4. 生成位图后浏览器进程间通信的过程，显卡缓存与显示器的关系。

## 五层网络模型

- 物理层：光纤、铜（硬件）
- 数据链路层：mac地址（硬件）
- 网络层：IP地址——IP协议
- 运输层：TCP协议、UDP协议
- 应用层：HTTP协议、DNS协议

## TCP 三次握手与四次挥手（一发一收，有来有回）

1. 三次握手：
    - 第一次握手：浏览器向服务器发送 syn 包。
    - 第二次握手：服务器收到 syn 包，确认后，向浏览器也返回一个 syn + ack 包
    - 第三次握手：浏览器收到服务器的确认信息后，向服务器发送一个收到的包，并完成连接。
2. 四次挥手
    - 第一次挥手：浏览器向服务器发起断开连接的请求
    - 第二次挥手：服务器向浏览器发生一个收到断开连接请求的信息，但还不能断开
    - 第三次挥手：服务器向浏览器发生一个可以断开连接的信息。
    - 第四次挥手：浏览器向服务器发送收到断开连接信息，并且断开连接。

## TCP 与 UDP 的区别

- TCP：连接稳定，可靠；
- UDP：可能丢包，不保证。

## TCP/IP 协议和 HTTP 协议的区别

- HTTP 协议是基于 TCP/IP 协议的；
- TCP/IP 连接要求：对方 IP，自己 IP，对方端口；
- HTTP 连接要求：对方设置的请求头。

## HTTP 和 HTTPS 的区别

- HTTP 超文本传输协议，是一个客户端和服务端请求应答的标准，HTTPS 是以安全为目的安全版本，在 HTTP 下加入了 ssl 层，安全的基础就是 ssl，因此加密的详细内容需要 ssl
- HTTP 信息是明文传输的，而 HTTPS 是安全的，需要进行 ssl 加密传出，HTTP 标准端口是 80，HTTPS 是 443，HTTP 无需证书，HTTPS 需要认证证书要到 CA 进行申请。

## GET 和 POST 的区别

- 看是基于什么前提，如果没有任何规范，两者没有任何区别，只有名字不同
- 如果是基于 RFC 规范的
    1. 从缓存角度：GET 请求会被浏览器主动缓存下来，留下历史记录，后退刷新无影响，POST 会重新提交，也不会缓存；
    2. 从编码角度：GET 只进行 URL 编码，只能接收 ASCll 字符，长度限制 255 个字符，而 POST 不会也没有长度限制；
    3. 从参数角度：GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息；
    4. 从幂等性角度：GET 是幂等的，而 POST 不是（幂等：执行相同的操作，结果也是相同的）；
    5. 从 TCP 角度：GET 请求会把请求报文发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应100(continue)，然后发 body 部分（火狐除外，它的 POST 请求只发一个 TCP 包）。

## 常见的HTTP状态码

- 1xx：表示目前是协议中间处理状态，还需后续操作；
- 101：在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101；
- 200：是常见最多的成功的状态码，通常在响应体中放有数据；
- 204：请求成功，但响应头后没有 body 数据；
- 206：表示部分内容，使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段：Content-Range；
- 301:   永久重定向（网上迁移，HTTP 向 HTTPS 协议升级）浏览器会做缓存优化，再次访问会自动重定向到那个地址；
- 302：临时重定向，暂时不可用；
- 303：查找其他地址；
- 304：当协商缓存命中时会返回 304；
- 400：请求出错，较为笼统，并不知道哪里出错了；
- 403：服务器禁止访问（法律禁止、信息敏感）；
- 404：未找到资源，不存在；
- 405：请求方法不被服务端允许；
- 406：资源无法满足客户端的条件；
- 408：服务器等待了太长时间；
- 409：多个请求发生了冲突；
- 413：请求数据过大；
- 414：请求行里的 URI 太大；
- 429：客户端发送请求过多；
- 413：请求头字段内容过大；
- 500：请求出错，出了啥错咱也不知道；
- 501：表示客户端请求的功能还不支持；
- 502：服务自身正常，但访问时出错；
- 503：服务器忙，系统维护，服务器无法处理客户端的请求

## 如何解决跨域问题

> 跨域条件：协议、域名、端口都相同

1. jsonp 处理（页面引入带有 src 属性的标签）；
2. 服务器代理（nginx）
3. iframe：window.postMessage(obj,son)。父亲向儿子发送obj数据（页面嵌套）；
4. 跨域资源共享：后台服务设置请求头，允许任意 IP 可进行请求。

## HTTP 请求方法

- GET：通常用来获取资源
- HEAD：获取资源元信息
- POST：提交数据，上传数据
- PUT：修改数据
- DELETE：删除资源
- CONNECT：建立连接隧道，用于代理服务器
- OPTIONS：列出可对资源实行的请求方法，用来跨域请求
- TRACE：追踪请求-响应的传输路径

## HTTP 版本区别

1. HTTP 0.9 （1991）
   - 只有一个 GET 请求
2. HTTP 1.0 （1996.05）
   - 加入了大量内容
3. HTTP 1.1 （1997.01）
   1. 缓存处理：引入了更多的缓存控制策略 Cache-Control、Etag/If-None-Match 等；
   2. 错误状态管理：新增 24 个状态码 409（资源冲突）， 410（永久删除） 等；
   3. 范围请求：引入了 range 头域，只允许请求资源部分内容，返回码为 206，便于充分利用带宽连接；
   4. Host 头：加入 hostname 属性，可请求同一台服务器上的不同网站
   5. 持久连接：默认开启 Connection: keep-alive，即 TCP 连接默认不关闭，可被多个请求所复用。

> 缺点：管道机制，请求的用户需要排队等候

4. HTTP 2.0  （2015）
   1. 二进制分帧：信息和数据体都为二进制，头信息帧和数据帧；
   2. 多路复用（双工通信）：客户端可同时发送多个请求，并行的在同一个 TCP 连接上交换信息；
   3. 数据流：数据包不再按照顺序发送，将每个数据流做编号，奇数 ID 为客户端发出的，偶数 ID 为服务器发出的，数据流发送到一半的时候可以被取消。客户端还可以指定数据流的优先级，优先级越高，服务器越早回应；
   4. 首部压缩：引入头部压缩机制 header compression，将请求字段进行记录（客户端与服务端会同时维护一张表），当被再次请求的时候发送表中的索引号，提高效率；
   5. 服务端推送：主动向客户端发送资源。

## 怎样优化 HTTP 1.1 请求

1. 最直接的就是减少 HTTP 请求（减少 DNS 请求所耗费的时间，减少服务器压力，减少 HTTP 请求头）；
    - 雪碧图；
    - 内联图片（data:url）；
    - 合并脚本与样式表。
2. 使用 CDN 服务器将内容缓存，减少与个服务器的直接交互；
3. 建立一次 TCP 连接是成本是很高的，合理设置 keepalive_timeout 字段，传输多个文件，可以有效的减少连接时间；
4. 减轻 HTTP 请求对头阻塞问题，多分几个域名并指向同一台服务器；
5. 在字段较大的时候使用分块传输编码：以“流模式”取代“缓存模式”，设置字段：Transfer-Encoding: chunked。

## HTTP 缺点

1. 无状态：
    - 优点：若仅仅只是为了获取一些数据，不需要保存连接在上下文信息，无状态反而减少了网络开销；
    - 长连接场景下，需保存大量的上下文信息，以免传输大量重复信息。
2. 明文传输（主要指头部，不使用二进制数据，而是文本形式）：
    - 优点：方便调试；
    - 缺点：WIFI 陷阱就是利用 HTTP 明文传输的缺点然后疯狂抓你所有的流量，拿到你的敏感信息。
3. 对头阻塞问题（TCP 一发一收，有来有回）：
    - 缺点：开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，耗时过长的情况下，其他请求只能处于阻塞状态。
    - 解决方式：一个域名可并发 6 个长连接，多分几个域名，而它们又指向同一台服务器。

## 使用 CDN 服务器的好处

- 内容有吸引力，支持频繁用户互动；
- 访问速度快；
- 可以在各处访问，无障碍；
- CDN 的负载均衡和分布式储存技术（异地备援），可以加强网站的可靠性。

## 页面长时间出现处于空白页可能是什么原因导致的？

1. 客户端：
    - JavaScript 异常，脚本文件过大或出现错误问题；
    - 无效请求；
    - 错误路径（错误请求）；
2. 服务端：
    - 反向代理异常；
    - 服务器异常；
    - 服务器正常返回空白页面；
3. 网络：
    - DNS 解析异常；
    - 链接超时，在网速较慢，请求资源过大时容易导致；
    - 某些资源未加载到，形成了对头阻塞；
    - CDN 服务器异常（CDN 服务商异常、CDN 节点故障）。

## CSRF 攻击是什么，如何防范？

1. 通过跨域的方式请求服务器，得到用户信息（跨站请求伪造）
2. 防范：
    - 阻止跨域，并对跨域请求做验证加密
    - 设置 cookie 字段：SameSize

## XSS 攻击是什么，如何防范？

1. 利用原网页所留下的开发漏洞，插入恶意的 Script 代码
    - 盗取 cookie；
    - 破坏页面结构；
    - 流量劫持；
    - dos 攻击：攻击者占用更多的服务器资源，从而使用户无法正常访问；
2. 防范：
    - 将用户写入的内容进行编译
    - 设置 cookie 字段：HttpOnly

## DDos 攻击是什么，如何防范？

- 一堆无赖占用过多的服务器资源，导致正常用户无法访问；
- 流量型攻击，连接型攻击，特殊协议缺陷。
- 防范：
    - 如果可以识别攻击源，可以在防火墙放置一层 ACL 层，阻断这些访问源；
    - 对于宽带消耗攻击，最有效的方式就是增加宽带；
    - 提高服务器负载能力，安装 apachebooster 插件，应对突增流量和内存占用；
    - 启用路由器和防火墙的反 IP 欺骗功能；
    - 监控流量变化。

## 如何预防 SQL 注入

1. 数据校验：规避数据中含有分号、引号等特殊字符，使用 execute() 来保证每次执行单条语句；
2. 权限限制：对增、删、改这种权限较重的操作进行权限加强；
3. 日志记录：日志本身没用，要查阅其中的信息才行。

## 知道拖库（脱裤）洗库与撞库吗？

- 拖库：黑客（不法分子）从数据库资料中盗走的行为；
    - 攻击手段：水坑攻击（站点挂马）、邮件钓鱼（邮件发送木马）、社工管理员（得到管理员信息）、XSS劫持
- 洗库：从大量的数据库中获取有价值的信息；
- 撞库：很多用户喜欢用一样的账号密码登录不同的平台，黑客利用这一点在其他平台登录。
